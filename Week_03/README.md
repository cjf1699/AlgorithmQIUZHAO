# 学习笔记

## 内容总结

这一周跟着超哥学了不少知识点。

首先是递归。递归其实在上一周树的相关题目中已经应用的比较多了，但是这一周总结了递归的模板，思路变得清晰起来。遇到不会、懵逼的时候，先把递归模板套上：先terminator，然后process当前logic，再drill down，最后，如果说有修改全局变量或当前“梦境”中的量，就reverse，否则不需要。

至于分治和回溯，则可以看作是递归的两种具体的应用。关于回溯的题我终于有了点感觉，其实无论是括号生成、电话号码、N皇后还是岛屿数量、扫雷等问题，其实都有一个“层级”的概念在里面：有当前层，有最大层，那么回溯的问题就简单了，一开始一定要判断当前level是否超过了最大level，如果是，就把当前的结果加到最终的结果中去；如果不是，那就来处理当前层的问题，然后呢，就下探到下一个level去，而这里的下探可能有许多选择，如果是括号那个问题，那就是选与不选两种选择，若选择多于两种，就可以搞一个循环依次尝试，本质上和递归的模板是一样的。

搜索。dfs用的多一些，而且往往代码比较简洁，因为系统可以帮我们维护函数调用栈，而bfs的话需要我们自己维护队列。bfs要注意不要重复入队的问题。

贪心算法比较巧妙，证明的话我不太会，就先记住几种典型的用贪心的情况吧，比如买卖股票、凑零钱当币值为倍数关系时、分饼干等。贪心算法和动态规划都适用于存在最优子结构的问题，但是贪心不能回退。贪心一旦能用，那么其时间复杂度是最优的。

二分查找的模板相对比较固定，但是边界条件需要格外注意。能用二分的三个条件：单调，有界，索引。还有就是像搜索旋转排序数组这题，虽然不单调，但是局部单调的话我们可以转化为局部二分也是可以的。

关于这题，超哥留的作业是如何在log n内找到无序点，我觉得可以这样：

```c++
// [4,5,6,7,0,1,2]
    int findRotate(vector<int>& nums) {
        int lo = 0, hi = nums.size() - 1;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if (nums[mid] >= nums[0])   lo = mid + 1;
            else    hi = mid;
        }
        return hi;
    }
```

